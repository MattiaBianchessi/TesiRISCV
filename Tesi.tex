%%%%
\documentclass[12pt, a4paper]{report}

% packages...
\usepackage[utf8]{inputenc}
\usepackage[english, italian]{babel}
\usepackage[hyphens]{url}
\usepackage{csquotes}
\usepackage{caption}
\usepackage{subcaption}
% Per generare il file PDF aderente alle specifiche PDF/A-1b. Verificarne poi la validità.
%\usepackage[a-1b]{pdfx}

\usepackage{hyperref}
\usepackage{graphicx}
\graphicspath{ {Img/} }
\usepackage{lipsum}% Per inserire testo a caso in attesa di realizzare i capitoli
\usepackage{listings}
\usepackage{epigraph} % per le frasi inizio capitolo
\usepackage{fancyhdr}
% \usepackage{refcheck}

\usepackage{pgfplots} 
%\pgfplotsset{compat=1.18} 

\usepackage{verbatim}

\lstset{
	% 	language=bash
	frame=single, 
	breaklines=true, 
	postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}}, 
	basicstyle=\ttfamily\footnotesize
}

%MyStyle
\renewcommand{\lstlistingname}{Code}

\definecolor{codegray}{rgb}{0.5, 0.5, 0.5}
\definecolor{codepurple}{rgb}{0.58, 0, 0.82}
\definecolor{backcolour}{rgb}{0.95, 0.95, 0.92}

\lstdefinestyle{Cstyle}{
 backgroundcolor=\color{backcolour}, 
 keywordstyle=\color{blue}, 
 numberstyle=\tiny\color{codegray}, 
 stringstyle=\color{codepurple},
 basicstyle=\ttfamily\footnotesize, 
 breakatwhitespace=false, 
 breaklines=true, 
 captionpos=b, 
 keepspaces=true, 
 numbers=left, 
 numbersep=5pt, 
 showspaces=false, 
 showstringspaces=false, 
 showtabs=false, 
 tabsize=2, 
 frame = leftline
}

% RISC style
\lstdefinelanguage{Risc-v}
{
 alsoletter={.}, % allow dots in keywords
 alsodigit={0x}, % hex numbers are numbers too!
 morekeywords=[1]{ % instructions
 lb, lh, lw, lbu, lhu,
 sb, sh, sw, 
 sll, slli, srl, srli, sra, srai, 
 add, addi, sub, lui, auipc, addiw
 xor, xori, or, ori, and, andi, 
 slt,slti, sltu, sltiu, 
 beq, bne, blt, bge, bltu, bgeu, 
 j,jr, jal, jalr, ret, 
 scall, break, nop
 }, 
 morekeywords=[2]{ % sections of our code and other directives
 .align, .ascii,.asciiz, .byte,.data, .double,.extern, 
 .float, .globl, .half, .kdata, .ktext, .set, .space, .text, .word
 }, 
 morekeywords=[3]{ % registers
 zero, ra,sp, gp,tp, s0,fp, 
 t0, t1,t2, t3,t4, t5, t6, 
 s1,s2, s3, s4,s5, s6, s7,s8, s9, s10,s11, 
 a0,a1, a2, a3,a4, a5, a6, a7,
 ft0, ft1, ft2,ft3, ft4,ft5, ft6,ft7, 
 fs0, fs1,fs2, fs3, fs4,fs5, fs6, fs7,fs8, fs9, fs10,fs11, 
 fa0, fa1, fa2, fa3, fa4, fa5, fa6,fa7
 }, 
 morecomment=[l]{;}, % mark ; as line comment start
 morecomment=[l]{\#},% as well as # (even though it is unconventional)
 morestring=[b]", % mark " as string start/end
 morestring=[b]' % also mark ' as string start/end
}

\lstset{
 % listings sonderzeichen (for german weirdness)
 literate={ö}{{\"o}}1
 {ä}{{\"a}}1
 {ü}{{\"u}}1,
 basicstyle=\tiny\ttfamily, % very small code
 breaklines=true, % break long lines
 commentstyle=\itshape\color{green!50!black}, % comments are green
 keywordstyle=[1]\color{blue!80!black},% instructions are blue
 keywordstyle=[2]\color{orange!80!black}, % sections/other directives are orange
 keywordstyle=[3]\color{red!50!black}, % registers are red
 stringstyle=\color{mauve}, % strings are from the telekom
 identifierstyle=\color{teal}, % user declared addresses are teal
 frame=l, % black line on the left side of code
 language=Risc-v, % all code is RISC-V
 tabsize=4, % indent tabs with 4 spaces
 showstringspaces=false % do not replace spaces with weird underlines
}

%--- BIBIOGRAFIA
 \usepackage[ backend=biber,
sorting=ynt, 
%citestyle=authoryear 
]{biblatex}

\addbibresource{Bibliografia.bib}
%---

\usepackage[textwidth=2cm, textsize=scriptsize,colorinlistoftodos]{todonotes}
\setlength {\marginparwidth }{2cm}
%\usepackage[disable]{todonotes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
% Frontespizio
\begin{titlepage}
\begin{center}
\includegraphics[width=\textwidth]{Img/Logo.jpg}\\
{\large{\bf Corso di Laurea Informatica}}
\end{center}
\vspace{12mm}
\begin{center}

\vspace{4mm}
{\huge{\bf RISC-V stress testing}}\\
\vspace{4mm}

\end{center}
\vspace{12mm}
\begin{flushleft}
{\large{\bf Relatore:}}
{\large{Trentini Andrea}}\\
\vspace{4mm}
{\large{\bf Correlatore:}}
{\large{Carraturo Alexjan}}\\
\end{flushleft}
\vspace{12mm}
\begin{flushright}
{\large{\bf Tesi di Laurea di:}}
{\large{Bianchessi Mattia}}\\
{\large{\bf Matr. 931455}}\\
\end{flushright}
\vspace{4mm}
\begin{center}
{\large{\bf Anno Accademico 2021-2022}}
\end{center}
\end{titlepage}


\listoftodos


\tableofcontents
\listoffigures
\listoftables
\lstlistoflistings



%%%%%%%%
\chapter{Introduzione}
%\textbf{Oggetto della tesi}
Il processore è il componente hardware con il quale vengono svolte le istruzioni.
Oggigiorno sono presenti numerosi processori, ognuno caratterizzato da un insieme di istruzioni che definiscono  cosa un processore può eseguire. RISC-V, con un \textit{istruction set} basato su un approccio \textit{reduced instruction set computer}\cite{RISCOverview}, sta facendo parlare di sè \cite{RISCVHistory}.

%\textbf{OBIETTIVI}
L'obiettivo di questa tesi è quello di fare alcuni test sul processore dotato di RISC-V e valutarne le prestazioni.

%\textbf{METODI E STRUMENTI}
Per la valutazione sono stati utilizzati due benchmark (Coremark, LINPACK) e alcuni
codici in linguaggio C compilati con la \textit{toolchain} di RISC-V.I risultati dei test vengono riportati e, in alcuni casi, comparati con i risultati di programmi simili compilati per altri processori. Viene poi analizzato il codice sorgente generato in linguaggio macchina e confrontato con altri codici generati.

%\textbf{Struttura }
La tesi inizia con una panoramica sul progetto RISC-V presentando gli obiettivi e la storia del progetto. Il secondo capitolo mostra in sintesi l'ISA di RISC-V presentando alcuni punti importanti del progetto. Successivamente con il capitolo tre vengono presentati i compilatori mostrando la storia dalle origini fino ai compilatori moderni e la cross-compilazione. In particolare viene presentata la \textit{toolchain} utilizzata per la compilazione dei programmi.
Nei capitoli quattro e cinque vengono presentati i programmi utilizzati e i risultati ottenuti vengono analizzati nel capitolo sei.


% o sections (dipende dal documentclass)
\chapter{RISC-V}
% OUTLINE CH 1 
% ->>>>Un approccio meno giornalistico 
%	1- presentazione progetto, (1.1- obbiettivi )
%	2- storia \\
RISC-V è una ISA basato sul principio RISC nato come progetto accademico. Nel 2010, a Berkeley(California), il progetto inizi\'o diretto dal prof. David Patterson finanziato da \textit{Intel } e \textit{Microsoft} e da alcune aziende Californiane. La prima pubblicazione è dell'anno successivo. Nel 2015 viene fondata \textbf{RISC-V Foudation}, un' azienda no-profit che controlla lo sviluppo di RISC-V. Nel 2018 viene annunciata una collaborazione tra l'azienda e \textit{Linux Foundation} con la quale si supporta lo sviluppo del progetto RISC-V \cite{RISCOrgHistory}.


\section{Gli obbiettivi di RISC-V}
Durante la fase di progettazione, i progettisti hanno voluto mettere nero su bianco lo scopo di RISC-V. Gli obbiettivi dichiarati nell'introduzione della specifica dell'ISA user-mode sono:
\begin{itemize}
	\item un ISA con una licenza \textit{open source} disponibile per accademia e industria.
	\item un ISA adatta ad un'implementazione hardware diretta, non una simulazione.
	\item un ISA non specifica per una micro-architettura o una tecnologia ma che permetta un implementazione efficiente.
	\item un ISA modulare,organizzata in ISA più piccole con la possibilità di usare estensioni\footnote{Insiemi di istruzioni opzionali che possono essere aggiunte alla base dell'ISA di RISC-V per fornire funzionalità specifiche. Sezione \ref{estensioni}.}.
	\item supporto per lo standard floating-point 2008 IEEE-754 \footnote{ \url{https://ieeexplore.ieee.org/document/4610935} \cite{IEEE754-2008}}.
	\item supporto delle estensioni. 
	\item spazio di indirizzamento 32 e 64 bit.
	\item supporto a delle implementazioni multi core e manycore \footnote{I processori Manycore sono un tipo speciale di processori multi-core progettati per un alto grado di elaborazione parallela. Contengono numerose core più semplici e indipendenti. } sia eterogenei che omogenei.
	\item istruzioni a lunghezza variabile.
	\item un ISA completamente virtualizzabile.
	\item un ISA che permetta la semplificazione degli esperimenti con nuovi progetti ISA con \textit{supervisor-level} e \textit{hypervisor-level}. 
	
\end{itemize}

\section{Panoramica}
L'ISA RISC-V è un architettura load-store con solo 49 istruzioni base. L'ISA supporta sistemi di memoria sia \textit{little-endian} che \textit{big-endian}. Le istruzioni sono organizzate in pacchetti da 16-bit memorizzati in maniera \textit{little-endian} indipendentemente dall'\textit{endianness} del sistema. Ogni pacchetto ha nei bit meno significativi i bit per la codifica delle istruzioni. In questo le istruzioni di lunghezza variabile sono decodificate velocemente.

Le celle della memoria principale sono di lunghezza variabile a seconda dell'ISA base scelto, il numero di celle di memoria è XLEN e la dimensione della singola cella è di $2^{XLEN - 1}$. Ad esempio l'ISA RV32I ha un XLEN di 32. Lo spazio di indirizzamento è circolare quindi l'errore di overflow non c'è in quanto i calcoli degli indirizzi vengono scalati in modo adeguato dividendosi per un modulo adatto sfruttando cosi la caratteristica circolare \cite{ISA}.


%Modalita indirizzamento
Avendo tutte le istruzioni di lunghezza fissa, non è possibile avere direttamente costanti o indirizzi superiori alla lunghezza assegnata al campo dell'istruzione. La soluzione è l'utilizzo della modalità di indirizzamento:
\begin{itemize}
	\item \textbf{indirizzamento immediato}: l’operando è una costante nell’istruzione è comunque limitato dai bit assegnati del campo.
	\item \textbf{indirizzamento a registro}: l’operando è un registro.
	\item \textbf{indirizzamento di base con spostamento}: l’operando è la somma tra il
contenuto di un registro e una costante.
\item \textbf{indirizzamento relativo al PC}: l'operando dipende dal \textit{Program Counter} che viene sommato a una costante.
\end{itemize}


%Eccezioni, trap, iterrupt
Si parla di eccezione quando una condizione non comune avviene a \textit{run time} associata a un'istruzione.
Si parla di \textit{trap} quando si verifica un trasferimento di controllo da parte del \textit{trap handler}, da un \textit{thread} ad un altro. Si parla di \textit{interrupt} quando la situazione imprevista è qualcosa di esterno.



\section{Descrizione board} 

La scheda di sviluppo utilizzata è D1-H Nezha basata sul design del chip Allwinner D1-H. La board integra una CPU Ali Pingtou Ge RISC-V C906, con clock a 1 GHz, supporta il kernel Linux standard, ha la memoria 2G DDR3, 258 MB di spin-nand, connessione WiFi/Bluetooth, con interfacce audio e video, può essere collegata a varie periferiche, MIPI-DSI+TP, supporta il collegamento con scheda SD, HDMI, auricolari da 3,5 mm, Gigabit Ethernet, USB,USB-C, UART, 40 pin.


\begin{figure}[!ht]
\includegraphics[width = \textwidth]{D1H-BoardTopView.png}
\caption{Board vista dall'alto}

\includegraphics[width = \textwidth]{D1H-BoardBlockView.png}
\caption{Schema a blocchi della scheda di sviluppo}\cite{BoardInfo}
\end{figure}

\vspace{2cm}

\begin{table}[!ht]
\centering
\begin{tabular}{| r | c |}
\hline
CPU & Allwinner D1-H \\
\hline
Clock & 1GHz\\
\hline
DRAM & DDR3 2GB\\
\hline
Memoria & 256MB spin-nand integrato\\
\hline 
Supporto memoria & USB e SD\\
\hline
Rete & Gigabit Ethernet, 2.4G WiFi e Bluetooth, antenna integrata\\
\hline
Display & MIPI-DSI + TP, HDMI,SPI \\
\hline
Audio & jack per cuffie da 3,5 mm\\
\hline
Tasti & FEL, LRADC OK\\
\hline
Luci & alimentazione, LED tricolore\\
\hline
DEBUG & UART, USB ADB\\
\hline
USB & USB, USB OTG, USB2.0\\
\hline
PIN & array di pin 40\\
\hline
Alimentazione & USB-C 5V-2A\\
\hline
Dimensioni & 85 x 56 x 1,7 mm\\
\hline

\end{tabular}
\caption{Caratteristiche della board}
\end{table}

\section{Ambiente di sviluppo}
La scheda di sviluppo D1-H viene fornita con il sistema Tina Linux. Il kernel fornito \'e adattato al kernel Linux 5.4. La board fornisce il supporto di base e gestione delle risorse hardware del dispositivo. Ulteriori informazioni sono disponibili sul sito della board
\footnote{Link al sito della board in esame \url{https://d1.docs.aw-ol.com/study/study_1tina/}}.


%%
% Capitolo 2
% BASE -> ESTENSIONI
% 
\chapter{ISA RISC-V}
\todo{Rileggere}
Prima di discutere dei risultati ottenuti presentiamo L'\textit{Instruction Set Architecture} o \textbf{ISA}.
%BASE ED ESTENSIONE
\section{Base}
RISC-V prevede un nucleo di istruzioni di base mediante le quali si può supportare dei sistemi funzionanti. Esistono diversi nuclei base denominati a seconda di quanti bit utilizza il sistema. Esistono 4 basi:
\begin{itemize}
	\item RV32I, che ha lo spazio di indirizzamento di 32 bit. 
	\item RV64I, che ha lo spazio di indirizzamento di 64 bit.
	\item RV128I, che ha lo spazio di indirizzamento di 128 bit.
	\item RV32E, sotto-insieme di RV32I che ne offre un supporto simile ed è pensata per dispositivi \textit{embedded}.
\end{itemize}
Tutte le ISA base usano il complemento a due per la rappresentazione di valori interi con segno. Le basi per la computazione a valori interi è identificata dalla lettera "I". 

%Perche avere estensioni
%%?
\section{Estensioni} \label{estensioni}
Se si utilizza solo una base si hanno solo delle funzionalità basilari, per questo motivo vengono introdotte le estensioni. Le estensioni dell'ISA di RISC-V sono insiemi di istruzioni opzionali che possono essere aggiunte alla base dell'ISA di RISC-V per fornire funzionalità specifiche e personalizzate. L'ISA base di RISC-V è progettata per essere estensibile in modo modulare, il che significa che le estensioni possono essere aggiunte senza influire sulla compatibilità con il software esistente.

Usare un'estensione significa estendere le funzionalità e aggiungere il supporto per determinate azioni. Di seguito vengono riportate alcune estensioni:
\begin{itemize}
		\item "M", aggiunge istruzioni per le operazioni di moltiplicazioni e divisioni di interi.
		\item "A" istruzioni atomiche, istruzioni di lettura-scrittura-modifica atomiche. % Atomiche = def?
		\item "F"istruzioni a virgola mobile a singola precisione, aggiungendo anche registri.
		\item "D" istruzioni a virgola mobile a doppia precisione.
		\item "C" istruzioni a 16 bit.
\end{itemize}

Le estensioni, possono essere di tre tipi in base alla standardizzazione:
\begin{itemize}
	\item \textbf{standard} definite dalla RISC-V Foundation, come le sopra citate.
	\item \textbf{reserved} non ancora definite ma riservate per usi futuri.\footnote{utilizzato dalle aziende per la progettazione di processori personalizzati e spesso aggiungono estensioni proprietarie per soddisfare esigenze specifiche del loro settore o dei loro clienti.}
	\item \textbf{non standard} non ancora standardizzate o ampiamente adottate.
\end{itemize}

\begin{table}
\centering
\begin{tabular}{|c|l|c|}
\hline
Base & Versione & Definitiva? \\
\hline
RV32I & 2.0 & S\\
RV32E & 1.9 & N\\
RV64I & 2.0 & S\\
RV128I & 1.7 & N\\
\hline
Estensione & Versione & Definitiva? \\
\hline
M & 2.0 & S\\
A & 2.0 & S\\
F & 2.0 & S\\
D & 2.0 & S\\
Q & 2.0 & S\\
L & 0.0 & N\\
C & 2.0 & S\\
B & 0.0 & N\\
J & 0.0 & N\\
T & 0.0 & N \\
P & 0.1 & N\\
V & 0.2 & N\\
N & 1.1 & N\\
\hline

\end{tabular}
	\caption{Tabella nomenclatura ISA RISC-V}
	\label{tab:nomenclaturaISA}
\end{table}

La tabella \ref{tab:nomenclaturaISA}, presa da SPEC-2.2 \cite{ISA}, presenta i set base e le estensioni standard con le rispettive versioni. Ogni base o estensione presenta la casella "Definitiva" che specifica se il set o l'estensione è definitiva (S) o non lo è (N).


\section{Istruzioni base}
Di base l'ISA presenta un piccolo insieme di istruzioni Le istruzioni base sono solamente 47 e vengono codificate in 6 formati (R/I/S/U/B/J). 

\begin{figure}[h!]
	\includegraphics[width = \textwidth]{FormatiIstruzione.png}
	\caption{Formati istruzione RISC-V\cite{ISA}}
	\label{Fig:Formati_istruzioni_RV32I}
	
\end{figure}



In tutti i formati i registri sorgente (\textit{rs1} e \textit{rs2}) e il registro destinazione (\textit{rd}) vengono mantenuti nelle stesse posizioni per velocizzare la codifica.
L'ISA presenta 4 categorie di istruzioni:
\begin{itemize}
	\item \textbf{Istruzioni computazionali}: Sono presenti 21 istruzioni computazionali e vengono codificate nel formato R se è un'operazione tra i registri o nel formato I se è un'operazione tra registro e costante. Le istruzioni di questo tipo includono istruzioni aritmetiche, logiche e di comparazione sia per valore senza segno che per i valori con segno.
	\item \textbf{Accesso alla memoria}Le istruzioni di accesso alla memoria permettono il trasferimento di dati dalla memoria e alla memoria. Sono presenti 8 istruzioni in totale, 5 di load codificate nel formato I e 3 di store codificate nel formato S.
	\item \textbf{Controllo del flusso}Le istruzioni di controllo permettono di alterare il normale flusso sequenziale del programma. Sono presenti 6 istruzioni di questo tipo che permettono il trasferimento codificate nel formato B. Le istruzioni prevedono il confronto degli operandi in \textit{rs1} e \textit{rs2} e se la condizione è verificata viene aggiunto il valore del campo imm al \textit{program counter} per raggiungere l'indirizzo di arrivo.
	\item \textbf{Istruzioni di sistema}Con RV32I sono presenti 8 istruzioni di controllo del sistema. Possiamo dividerle in due gruppi. Il primo gruppo (ECALL, EBREAK) gestisce le \textit{system call}. Il secondo gruppo è utilizzato per leggere e scrivere i registri di stato.
\end{itemize}


\section{RV32I}
L'ISA base è stata progettata per supportare i moderni sistemi operativi. Questa base contiene 47 istruzioni uniche. I 32 registri sono di 32 bit (XLEN = 32) vengono identificati da x seguito da un numero. Il primo registro x0 contiene la costante zero e ogni istruzione che cerca di modificarlo solleva un eccezione. Gli altri registri x1 - x31 sono \textit{general purpose}. L'ABI definisce le convenzioni di utilizzo dei registri(Figura \ref{Fig:ConvenzioneRegistri}).

\begin{figure}[h!]
\centering
	\includegraphics[scale=0.3]{ABI-RISC-V}
	\caption{Convenzione dei registri}
	\label{Fig:ConvenzioneRegistri}
\end{figure}

Come mostrato in Figura \ref{Fig:ConvenzioneRegistri} notiamo che non è presente un registro dedicato allo \textit{stack pointer} ne un \textit{return adress} ma vengono utilizzati rispettivamente il registro x2 e il registro x1.


\section{Le altre basi}
Esistono altri set che aumentano i bit utilizzati dai registri come RV64I e RV128I. Tutto quello che è stato detto è valido anche per queste con alcuni accorgimenti che sollevano eccezioni di operazioni non valide.
Rispettivamente il valore di XLEN per RV64I e per RV128I è 128.


Sul documento che propone RISC-V sul proprio ISA vengono anche impostate le linee guida per fare delle proprie estensioni.



%%
%Capitolo 3: Compilatori
% cos è -> Storia -> Riguardo RISC-V -> due parole su gcc e clang

\chapter{Compilatori}
\todo{atrent: riletto, sempre ignorando i numerosi errori ortgrafici e fraseologici}

\section{Descrizione}
Un compilatore è un programma che trasforma il codice sorgente in linguaggio macchina. Il processo di compilazione prevede diverse fasi. La prima prevede un analisi lessicale da cui vengono generati dei token. La seconda, utilizzando i token, prevede un analisi sintattica e infine un analisi semantica dopo la quale viene generato il codice un codice intermedio. Questo codice intermedio attraversa una fase di ottimizzazione e infine viene generato il codice target \cite{GCC} \cite{LLVM}.


\begin{figure}
\centering
\includegraphics[width = \textwidth]{SchemaCompilatore.png}
\caption{Schema meccanismo di compilazione}
\label{Fig:MeccanismoCompilazione}
\end{figure}%\todo{fonte?} Questa l'ho fatta io 

Qualsiasi programma scritto in un linguaggio di programmazione di alto livello deve essere tradotto in codice oggetto prima di poter essere eseguito, quindi tutti i programmatori che utilizzano tale linguaggio utilizzano un compilatore o un interprete. I miglioramenti a un compilatore possono portare a un gran numero di funzionalità migliorate nei programmi eseguibili.

\section{Storia}
Il primo compilatore teorico fu pensato da Corrado Böhm che nel 1951 che lo sviluppò per la sua tesi di dottorato. Una prima implementazione di un compilatore è dovuta a Grace Hopper che ha anche coniato il termine ``compilatore''. Il programma, chiamato \textit{A-0 System}\cite{SystemA0}, funzionava come caricatore o linker, non come i moderni compilatori. E'importante menzionare che il codice sorgente della versione A-2, datata 1953, fu rilasciato ai clienti con lo scopo di sviluppare dei miglioramenti all UNIVAC, Pertanto, A-2 potrebbe essere considerato un esempio del risultato di una filosofia precoce simile al software libero e open source \cite{openSource1, openOrg, stallman2003software}. 
%\todo{aveva una licenza considerabile libera?!?} -> non ho trovato nessun riferimento al tipo di licenza.

\section{Cross-compilazione}
\label{Sec:Cross}
La cross-compilazione è il processo di compilazione del codice sorgente su un sistema diverso da quello in cui il codice verrà eseguito. In altre parole, il compilatore viene eseguito su una piattaforma diversa rispetto a quella di destinazione del software compilato. Ad esempio, si può compilare un'applicazione per un sistema operativo diverso o per un'architettura hardware diversa. La cross-compilazione è spesso utilizzata nel contesto dello sviluppo di software per dispositivi embedded, dove lo sviluppatore scrive il codice sorgente su un computer host più potente e poi lo compila per l'hardware a cui è destinato.


\section{Compilatori moderni}
Nel ecosistema dei compilatori moderni i due dei piu famosi sono: GCC e CLANG.
Il primo GCC (GNU Compiler Collection) fu creato nel 1987 oggi viene sviluppato da programmatori di tutto il mondo. Inizialmente nato per il linguaggio C oggi oggi supporta altri linguaggi come Java, C++, Objective C \cite{GCCstory}.

Il secondo nato nel 2005 sviluppato da Apple Inc. Inizialmente fu sviluppato con lo scopo di avere un compilatore Apple ottimizzato per i loro dispositivi\cite{ClangStory}.

\section{Un buon compilatore} %
La scelta di un compilatore per un progetto è una scelta importante.I processori, oggi, sono strutturati in pipeline supescalari e in altre complesse strutture interne. Inoltre i linguaggi moderni astraggono dalla struttura hardware per ottenere un linguaggio logico più generale. Quindi si predilige un approccio meno specifico e non incentrato sulla struttura della macchina.Gli standard dei linguaggi, si fanno sempre più espressivi e astratti. Questa espressività dei linguaggi aumenta l'onere dei compilatori che devono essere in grado di generare un buon codice assembly. La selezione di un compilatore è una scelta cruciale per il proprio progetto, si deve tener conto che la stessa porzione di codice, utilizzando compilatori differenti, può generare comandi assembly più o meno efficienti.
Oltre a generare programmi eseguibili ad alte prestazioni, i compilatori devono anche avere prestazioni elevate. Un progetto software di grandi dimensioni può contenere da centinaia a migliaia di singole unità di traduzione. Le unità di traduzione sono parti del codice sorgente che vengono tradotte dal compilatore in un file oggetto o in un file eseguibile. Ogni unità di traduzione può contenere migliaia di righe di codice. Oltre all efficienza delle prestazioni del codice generato si deve tener conto anche del tempo in cui si genera il codice.

Quindi, un buon compilatore ci permette di concentrarci sul processo di programmazione, piuttosto che farci preoccupare della struttura del sistema e deve essere in grado di produrre del codice che abbia delle buone performance in tempo relativamente breve.


\section{Toolchain di RISC-V}
In sistemi privi di un compilatore viene utilizzata la tecnica della \textbf{cross-compilazione}(Sezione \ref{Sec:Cross}). RISC-V mette a disposizione alcune \textit{toolchain} di compilazione. Una \textit{toolchain} è un insieme di programmi utilizzati sequenzialmente per la creazione di un software. In generale i programmi presenti sono un compilatore, un linker, un assembler, un debugger, un profiler, degli strumenti di analisi del codice e strumenti di gestione del progetto. Per RISC-V sono disponibili le \textit{toolchain gcc}\cite{toolchain_gcc} e \textit{toolchain clang}\cite{toolchain_clang}. Entrambe le \textit{toolchain} sono mantenute dalle community, quella piu aggiornata e utilizzata è quella del progetto GNU. Sul \href{https://wiki.riscv.org/display/HOME/RISC-V+Software+Ecosystem}{sit} sono elencate tutte le \textit{toolchain} disponibili ma anche offre una panoramica su tutto l'ecosistema RISC-V.


\subsubsection{GCC toolchain}
La toolchain GCC di RISC-V supporta linguaggi come C, C++, Objective-C, e Go. La versione corrente è la 12.2 (datata Agosto 2022). La toolchain ha aggionamenti molto di frequente. Ci sono quattro manutentori Andrew Waterman, Jim Wilson, Kito Cheng, Palmer Dabbelt .

\subsubsection{CLANG toolchain}
La toolchain LLVM/CLANG è sviluppata da \textit{lowRISC project} attualmente è alla versione 15.0.2. A differenza della \textit{toolchain gcc} è mantenuta solamente da Alex Bradbury.


%%%--------------------

\chapter{BenchMarking}
\todo{atrent: riletto, fraseologia a volte zoppicante, al solito ignoro ortografia (da rivedere MOLTO)}

Quando si parla di benchmark si intendono dei test di prova con lo scopo di fornire una valutazione delle prestazioni di un computer. In generale esistono due principali categorie di benchmark sintetici o applicativi. I primi hanno lo scopo dimisurare le prestazioni del sistema riguardo specifiche operazioni mentre gli ultimi si riferiscono a software applicativi. Come affermato da Wei Dai e Daniel Berleant in \textit{Benchmarking Contemporary Deep Learning Hardware and Frameworks: a Survey of Qualitative Metrics }\cite{benchmarkIntro} ci sono sette caratteristiche fondamentali che un benchmark deve avere:
\begin{enumerate}
 \item Rilevanza: i benchmark dovrebbero misurare caratteristiche importanti.
 \item Rappresentatività: le metriche delle prestazioni dovrebbero essere accettate dall'industria e dal mondo accademico.
 \item Equità: tutti i sistemi dovrebbero essere paragonati in modo equo.
 \item Ripetibilità: è possibile verificare i risultati dei benchmark.
 \item Rapporto costo-efficacia: i test di benchmark sono economici.
 \item Scalabilità: i test di benchmark dovrebbero funzionare sia su sistemi che possiedono poche risorse che numerose risorse.
 \item Trasparenza: le metriche utilizzate dovrebbero essere facili da capire.
\end{enumerate}
In questa sezione viene prima presentata la storia dei programmi di benchmark dalle origini fino a oggi presentando alcuni standard attuali di dei benchmark. Successivamente vengono approfonditi alcuni benchmark utilizzati.

% Tipi di benchmark ... aggiungere ?
 
\section{Storia}
Il primo benchmark citato in letteratura prende il nome di Whetstone i suoi autori H.J. Curnow e B.A. Wichmann svilupparono un programma con lo scopo di valutare le prestazioni in virgola mobile. Pubblicato nel 1976 questo benchmark fu il primo esempio di benchmark sintetico. La sua semplicità è data dalla sua organizzazione in moduli ognuno specializzato per un aspetto.
 Un altro benchmark è LINPACK che risale al 1979(non pensato per diventare un benchmark). Questo benchmark utilizza una libreria \textit{BLAS (Basic Linear Algebra Subprograms) } per esegui operazioni su vettori e su matrici per risolvere sistemi lineari. Lo scopo originale era quello di valutare le prestazioni in virgola mobile dei supercomputer dell'epoca ma poi fu utilizzato anche su architetture meno potenti\cite{LinpackSite}.
 Un altro benchmark simile è il famoso dhrystone, questo benchmark sintetico pubblicato nel 1984 ha lo scopo di valutare le prestazioni dei microprocessori e dei sistemi di elaborazione dati \cite{DhrystoneWP}.
 Tutti i programmi sviluppati prima dell introduzione di dhrystone erano pensati e scritti per valutare un unico aspetto. Il primo tentativo di avere un programma che valutasse più aspetti ci fu nel 1986. Il benchmark si chiama Livermore loops., questo benchmark è composto da ventiquattro loop interni che valutano aspetti differenti. 
 Dopo lo sviluppo di un programma \textit{general purpose} si iniziò a pensare a delle suite di test che permettono l'esecuzione solo di alcuni test che valutino determinati aspetti invece di un unico programma che svolga ogni valutazione pensata in fase di sviluppo.
Una delle prime raccolte di test degna di nota è la raccolta prodotta da \textit{Stanford University}e \textit{the University of California, Berkeley} quando in corrispondenza con la progettazione del primo sistema RISC furono raccolti piccoli programmi. Tra questi erano presenti programmi di permutazioni, di risoluzione di problemi come la torre di Hanoi, le otto regine di puzzle e altri tipo moltiplicazione di matrici, quicksort, bubblesort, treesort, moltiplicazione di matrici con valori in virgola mobile e FFT (\textit{Fast Fourier Transform}) (otto con valori interi, due per valori float). L'importanza di questo \textit{Stanford Small Programs Benchmark Set} è dovuta al primo confronto tra architetture RISC e CISC \cite{CommonBench}.
%%
 Nel 1988 fu fondata una cooperativa con lo scopo di produrre benchmark validi lo SPEC \cite{SPECSite}.% imparziali, significativi e pertinenti. 
 I programmi utilizzati fino ad ora erano di piccole dimensioni e, con il miglioramento delle tecnologie, non potevano valutare le nuove architetture. Cosi fu fondato lo SPEC (\textit{The Standard Performance Evaluation Corporation}) il cui scopo era ed è quello di mantenere delle suite di test standardizzate per le nuove generazioni di computer. 
 Cosi come nei sistemi comuni sono stati sviluppate delle suite di test anche per quanto riguarda il mondo embedded. Nel 1997 fu fondata EEMBC (\textit{l'Embedded Microprocessor Benchmark Consortium}) che, negli anni 2000, pubblicò una prima suite di test dedicati al mondo embedded \cite{EEMBCSite}. % nomi dei set in v1 ?
 Uno dei suoi prodotti più famosi il benchmark chiamato CoreMark pubblicato nel 2009. %sezione core Mark
 Sempre nel mondo embedded fu creata la suite di test Embench, nel 2019 \cite{embenchSite}. Questa suite di test è stata sviluppata da altri progetti come \textit{The Bristol Embecosm Embedded Benchmark Suite (BEEBS)}, \textit{MiBench, the WCET benchmark collection, DSPstone, the Simple Generic Library} e\textit{the Nettle low-level cryptographic library}\cite{NettleSite}\cite{vittekBorovanskyMoreauTurin2006, }\cite{DSPStoneSite} \cite{WCETSite} \cite{MiBenchSite}. % BEEBES -> For the reasoning behind the choice of benchmarks in BEEBS, see BEEBS: Open Benchmarks for Energy Measurements on Embedded Platforms (https://arxiv.org/abs/1308.5174)
 
 %Quali sono gli standard di settore?
 Oggi gli tra gli standard settore c'è il precedentemente citato SPEC, in particolare SPECint e SPECfp, il primo incentrato su prestazioni di calcolo con numeri interi e il secondo in virgola mobile. 
 Per quanto riguarda il mondo embedded EEMBC è uno standard riconosciuto che oltre a CoreMark ha sviluppato altri benchmark mirati per dispositivi specifici (AutoBench per dispositivi automotive e industriali, Netwoking2.0 per router e switch e altri). % \cite{EEMBCSite}
 Altri standard di settore sono TPC (\textit{Transaction Processing Performance Council}) che si ovvupa di creare dei benchmark per i DBMS\cite{TPCSite}. %Meh

%Openbenchmark
 Oltre agli standard di settore, con gli anni, si sono sviluppati dei benchmark e delle suite di test open source. Per citarne uno \textit{phoronix test suite} \cite{ PhoronixTestSuiteSite}
 che supporta Linux, Windows Osx, e altri sistemi e da la possibilità di eseguire dei benchmark in maniera semplice(con l unica richiesta di avere php) da linea di comando e i risultati possono essere caricati su OpenBenchmark \cite{OpenBenchmarkSite}.



\section{Benchmark standard}

\newpage
\subsection{CoreMark}
Per citare il sito ufficiale: 

\textit{CoreMark is a simple, yet sophisticated benchmark that is designed specifically to test the functionality of a processor core. Running CoreMark produces a single-number score allowing users to make quick comparisons between processors}. 

CoreMark è un benchmark che misura le prestazioni dei microcontrollori e delle CPU utilizzate nei sistemi embedded. In CoreMark sono implementati algoritmi di list processing, manipolazione di matrici, macchina a stati e CRC (controllo di ridondanza ciclico) . È progettato per funzionare su dispositivi da 8 bit a 64 bit\cite{CoreMark}.

CoreMark è un benchmark sintetico, come Dhrystone e, come Dhrystone, CoreMark è piccolo, portatile, gratuito \footnote{La licenza di CoreMark è la "CoreMark License Agreement". La CoreMark License Agreement stabilisce che l'utente può utilizzare il benchmark CoreMark solo per scopi di valutazione delle prestazioni dei microprocessori e non per fini commerciali.} ma, a differenza di Dhrystone, CoreMark ha regole di esecuzione e reporting specifiche ed è stato progettato per evitare aspetti problematici di Dhrystone. Mentre Dhrystone risulta un benchmark del compilatore CoreMark si focalizza su le capacita di lavoro della MCU o di una CPU \cite{analysis_EEMBC}.
I codice sorgente è disponibile nel repository Github \footnote{\url{https://github.com/eembc/coremark} \cite{RepoCoreMark}}.
		

\subsection{LINPACK}
Il LINPACK Benchmark è una misura della velocità di esecuzione in virgola mobile di un computer. Viene determinato eseguendo un programma che risolve un denso sistema di equazioni lineari. Durante gli anni si sono sviluppate tre versioni di questo programma. 

La prima versione viene chiamata LINPACK 100 ed è molto simile a la versione del 1979. La soluzione si ottiene attraverso $ \frac{2}{3n^3} + 2n^2 $ operazioni in virgola mobile con n = 100. La seconda versione si chiama LINPACK 1000 e differentemente risolve problemi con n = 1000. L'ultima verisione chiamata HPL (\textit{High-Performance Linpack}) è dedicata a una implementazione parallela di LINPACK\cite{LINPACK_PastPresFut} \cite{hplNetLib}.

% approfondisci	?

\section{Altri programmi} 

In questa sezione vengono presentati due programmi scritti da me che non sono standard di benchmarking. Il primo programma viene utilizzato per poi analizzare il codice assembly generato dal compilatore, mentre con il secondo vengono utilizzati degli algoritmi di sorting e comparato il tempo di esecuzione con gli stessi algoritmi eseguiti sul Raspberry.

%\todo{devi dichiarare l'autore e la motivazione}

\subsection{MultOrShift}
	Il programma confronta la velocità di esecuzione di moltiplicazione e divisione
aritmetiche con lo shift logico. Il programma genera un array di interi di
valori tra zero e maxInt e un array di potenze di due comprese tra due e
milleventiquattro. Entrambi gli array hanno mille elementi. Dopo la generazione
viene calcolato elemento per elemento il risultato e viene memorizzato il
tempo di esecuzione. Il risultato del programma `e il tempo medio di esecuzione
di mille operazioni per tipo (moltiplicazione normale, divisione normale, 
moltiplicazione tramite shift, divisione tramite shift). 
Lo scopo di questo programma è osservare la differenza delle implementazioni delle operazioni a livello assembly compilato con la \textit{tool-chain} di RISC-V e confrontarle con le stesse operazioni compilate per ARM.
		
		
\subsection{Sorting}
Vengono utilizzati degli algoritmi di \textit{sorting} per confrontare il tempo di esecuzione sulla board con gli stessi algoritmi su Raspberry.Gli algoritmi di sorting utilizzati sono:
\begin{itemize}
	\item BubbleSort
	\item InsertionSort
	\item QuickSort
	\item HeapSort
\end{itemize}

Ogni algoritmo viene eseguito su array di dimensione diversa 500, 1000, 5000, 10000, 20000, 35000, 50000. Per ogni dimensione vengono eseguite 150 prove sulle quali viene calcolato il tempo di esecuzione. Il programma informa per ogni gruppo di array il tempo massimo, il minimo e il tempo medio. Per alcuni algoritmi vengono utilizzate anche delle configurazioni particolari dell'array da ordinare, come ad esempio utilizzando il BubbleSort vengono ordinati array strettamente crescenti e strettamente decrescenti oltre che ai campioni casuali. Nella situazione generale gli array vengono generati con numeri interi casuali.


\chapter{Comparativa}
\todo{idem come sopra}

\section*{MacBook Air}
\label{sec:MacBook}
Per alcuni benchmark è stato utilizzato un MacBook Air per confronto. Il PC ha un processore 2, 2 GHz Intel Core i7 dual-core con memoria 8 GB 1600 MHz. Nelle sezioni successive i termini Pc fanno riferimento a questa architettura.

\section*{Raspberry Pi}

Il Raspberry Pi utilizzato è Raspberry Pi model B. La board datata 2013 è stata sviluppata come board scolastica e successivamente applicata a molti contesti come nel mondo embedded.
Con la dimensione di una carta di credito il Raspberry ha una RAM di 512 MB e una CPU da 700 MHz, due porte USB (Universal Serial Bus) e un'Ethernet da 100 MB porta. In aggiunta a ciò, ci sono pin di input/output (GPIO) per uso generico per collegare alcuni hardware. La tabella \ref{Tab:RaspSorting} mostra i tempi di esecuzione degli algoritmi di ordinamento eseguiti su Raspberry \cite{Rasp}.

\begin{figure}[ht]
\centering
	\includegraphics[scale=0.5 ]{RBTop.jpeg}
	\caption{Vista superiore Raspberry model B}
	\label{fig:RaspberryB}
\end{figure}

\section{CoreMark}
CoreMark è stato compilato con:

\begin{lstlisting}[language=sh, caption = {compilazione CoreMark}, captionpos = b]
./riscv64-unknown-elf-gcc -O2 -o coremark.exe core_list_join.c core_main.c core_matrix.c core_state.c core_util.c simple/core_portme.c -DPERFORMANCE_RUN=1 -DITERATIONS=1000
\end{lstlisting}



I codici sorgente sono stati compilati utilizzando alcuni file di configurazione per RISC-V presenti nella \href{https://github.com/riscv-boom/riscv-coremark}{repository}\cite{CoreMarkWrapper}. I file utilizzati non alterano la validità dell esecuzione di CoreMark
\cite{CoreMarkRepo}.

Il programma è stato eseguito quindici volte con i seguente risultato:


\begin{table}[ht]
\begin{tabular}{|l|l|l|l|l|l|l|l|}
\hline
  & Score       &   & Score       &    & Score       &    & Score       \\ \hline
1 & 2312,479985 & 5 & 2311,881624 & 9 & 2311,874448 & 13 & 2311,444275 \\ \hline
2 & 2312,596169 & 6 & 2311,149103 & 10 & 2311,432578 & 14 & 2310,397101 \\ \hline
3 & 2311,137567 & 7 & 2310,215865 & 11 & 2311,265017 & 15 & 2311,553826 \\ \hline
4 & 2311,144929 & 8 & 2312,048460 & 12 & 2311,013694 &  &  \\ \hline
\end{tabular}
\caption{Score di CoreMark ad ogni esecuzione}
\end{table}


\begin{table}[ht]
\centering
\begin{tabular}{|l|c|}
\hline
Media & 2311, 307997 \\ \hline
Dev.std & 0, 754112 \\ \hline
\end{tabular}
\caption{Score medio e deviazione standard di CoreMark}
\end{table}


\begin{table}
\centering
\begin{tabular}{|l|l|l|l|l|l|l|}
\hline
&
 Cortex A72 &
 BCM2837 &
 BCM2835 &
 D1 &
 A20 &
 X1000E 
 \\ \hline
CoreMark & 48.626 & 15.364 & 1.303, 8 & 2.240, 8 & 2.086, 2 & 2.231, 1 \\ \hline
CoreMark/MHz & 22, 670 & 12, 803 & 1, 8625 & 2, 2408 & 2, 0862 & 2, 2311 \\ \hline
\end{tabular}
\end{table}

\section{LINPACK}
Il benchmark sia nella versione LINPACK100 che LINPACK1000 è stato compilato con:

\begin{lstlisting}[language=sh, caption = {compilazione LINPACK}, captionpos = b]
gcc -O4 -DDP -DROLL -o linpackc linpack.c -lm
\end{lstlisting}


Il programma è stato eseguito quindici volte con i seguente risultato:

\begin{table}[ht]
\begin{tabular}{|l|l|l|l|l|l|l|l|}
\hline
  & MFLOPS     &   & MFLOPS     &    & MFLOPS     &    & MFLOPS     \\ \hline
1 & 169,004840 & 5 & 163,725958 & 9 & 170,431042 & 13 & 175,125393 \\ \hline
2 & 166,062072 & 6 & 161,682756 & 10 & 175,125393 & 14 & 175,528289 \\ \hline
3 & 168,424495 & 7 & 163,999682 & 11 & 173,313142 & 15 & 173,094698 \\ \hline
4 & 168,672726 & 8 & 169,840877 & 12 & 175,573170 &  &  \\ \hline
\end{tabular}
\end{table}

\begin{table}[ht]
\centering
\begin{tabular}{|l|l|l|}
\hline
N & 100 & 1000 \\ \hline
Media & 170, 098131 & 120, 066523 \\ \hline
Dev.std & 4, 565740 & 0, 282790 \\ \hline
\end{tabular}
\caption{MFLOPS LINPACK}
\end{table}

\begin{table}[ht]
\centering
\begin{tabular}{|l|l|l|}
\hline
N & 100 & 1000 \\ \hline
Media & 0, 004040 & 5, 569164 \\ \hline
Dev.std & 0, 000109 & 0, 013134 \\ \hline
\end{tabular}
\caption{Tempo di risoluzione LINPACK}
\end{table}

\section{MultOrShift}
Il programma confronta la velocità di esecuzione di moltiplicazione e divisione aritmetiche con lo shift. Il programma genera un array di interi di valori tra zero e maxInt e un array di potenze di due comprese tra due e milleventiquattro. Entrambi gli array hanno mille elementi. Dopo la generazione viene calcolato elemento per elemento il risultato e viene memorizzato il tempo di esecuzione. Il risultato del programma è il tempo medio di esecuzione di mille operazioni per tipo (moltiplicazione normale, divisione normale, moltiplicazione tramite shift, divisione tramite shift). Di seguito alcune porzioni di codice:

\lstinputlisting[language=c, style = Cstyle, caption = Impostazioni dei dati, label ={Code:Init} ]{PorzioniCodice/MultShift/init.c}
\lstinputlisting[language=c, style = Cstyle, caption = Moltiplicazione, label ={Code:Mult} ]{PorzioniCodice/MultShift/Mult.c}
\lstinputlisting[language=c, style = Cstyle, caption = Shift, label ={Code:Shift} ]{PorzioniCodice/MultShift/Shift.c}

Il codice \ref{Code:Init} imposta i due array. I codici \ref{Code:Mult} e \ref{Code:Shift} mostrano l'operazione eseguita.
La tabella \ref{Tab:tempi_esecuzioneMS} mostra i tempi di esecuzione calcolati in millisecondi delle varie operazioni.

\begin{table}[ht]
\centering
\begin{tabular}{lcccc}
\cline{2-5}
\multicolumn{1}{l|}{} & \multicolumn{2}{c|}{PC} & \multicolumn{2}{c|}{RISC-V} \\ \hline
\multicolumn{1}{|l|}{Normale} & \multicolumn{1}{c|}{0.0036} & \multicolumn{1}{c|}{0.0042} & \multicolumn{1}{c|}{0.0430} & \multicolumn{1}{c|}{0.0572} \\ \hline
\multicolumn{1}{|l|}{Shift} & \multicolumn{1}{c|}{0.0034} & \multicolumn{1}{c|}{0.0034} & \multicolumn{1}{c|}{0.0404} & \multicolumn{1}{c|}{0.0826} \\ \hline
 & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} 
\end{tabular}
	\caption{Tempi di esecuzione operazioni calcolati in ms}
	\label{Tab:tempi_esecuzioneMS}
\end{table}
	
	
\section{Analisi codice assembly}
Per capire meglio i risultati osserviamo e compariamo i codici generati dai compilatori. I Compilatori confrontati sono \textit{gcc RISC-V}, \textit{gcc ARM} e \textit{gcc x86\_64}. I compilatori RISC-V e ARM vengono confrontati per il loro focus sul ambiente embedded ed entrambi sono architetture RISC.Tutti i codici presentati in questa sezione vengono compilati e presentati con il livello di ottimizzazione di default (-O0) \cite{ConfrontoISABook}.


\subsection{Addizione con costante}

\lstinputlisting[language=c, style = Cstyle, caption = Addizione, label = {Code:AddComp}]{PorzioniCodice/ConfrontoCompilatori/C/get_num.c}

La funzione è una semplice funzione scritta in C che dato un numero di tipo intero restituisce il numero sommato a ventitré \footnote{La scelta del numero è puramente casuale}.
  
\vspace{0.3 cm}
\textbf{RISC-V}

\vspace{0.3 cm}
Il sorgente compilato con il compilatore RISC-V \ref{Code:AddRISCV} da riga due fino a riga sei predispone la chiamata della procedura posizionando sullo stack il necessario, da riga sette inizia la funzione. Su quella riga viene recuperato il valore di \textit{num} che alla riga otto, tramite l'operazione di add immediate, viene sommato a num. Il risultato dell'operazione addiw è la somma del valore di num sommato alla costante ventitré, il risultato è esteso su sessantaquattro bit, vengono ignorati gli errori di overflow. Successivamente tramite la pseudo istruzione sext.w che prende i 32 bit inferiori e li memorizza nel registro rd. Questa istruzione corrisponde a addiw rd, rs, 1 0. Il risultato viene spostato nel registro a0 che, nei processori RISC-V, viene utilizzato come restituzione di risultato. Le righe successive ripristinano lo stack e restituisce il controllo al chiamante.

\vspace{0.3 cm}
\textbf{ARM}

\vspace{0.3 cm}

l sorgente \ref{Code:Addx86}, compilato con gcc ARM, mostra che la preparazione della procedure si esegue da riga due a riga cinque, le con le due righe successive si esegue la funzione. La riga sei recupera il valore di num la riga successiva calcola il valore del risultato e, infine, alla riga otto si sposta il risultato nel registro di restituzione


\vspace{0.3 cm}
\textbf{x86}

l sorgente \ref{Code:AddARM} è compilato con gcc di x86. Da riga due fino a riga quattro viene preparato lo stack, a riga cinque viene posizionato num nel registro eax che a riga sei viene sommato a ventitré che viene memorizzato nel registro eax. Infine viene ridato il controllo al chiamante.

\vspace{0.3 cm}

\begin{figure}[ht]
 
 \begin{subfigure}{0.3\textwidth}
 
 \lstinputlisting[language = Risc-v, caption = {RISC-V}, label = {Code:AddRISCV} ]{PorzioniCodice/ConfrontoCompilatori/Assembler/RISC-V/get_num.txt}


 \end{subfigure}
 \hfill
 \begin{subfigure}{0.3\textwidth}
 
 \lstinputlisting[language = Risc-v, caption = {Arm}, label = {Code:AddARM}]{PorzioniCodice/ConfrontoCompilatori/Assembler/ARM/get_num.txt}


 \end{subfigure}
 \hfill
 \begin{subfigure}{0.3\textwidth}
 
 \lstinputlisting[language = Risc-v, caption = {x86}, 	label = {Code:Addx86}]{PorzioniCodice/ConfrontoCompilatori/Assembler/x86/get_num.txt}


 \end{subfigure}
 
 \caption{Funzione di somma}
 
\end{figure}

\subsection{Addizione}
Nel caso generale viene calcolata la somma di tre numeri.
\lstinputlisting[language=C, style = Cstyle, caption = {Addizione generale}, label = {Code:Add2Comp}]{PorzioniCodice/ConfrontoCompilatori/C/sumGen.c}


\vspace{0.3 cm}
\textbf{RISC-V}

Nel caso del compilatore RISC-V la somma avviene tra tredici e diciannove dove gli operandi vengono caricati nei registri a4 e a5, successivamente calcolato il risultato e memorizzato in a4 che poi verrà sommato con l'ultimo operando, caricato a riga diciassette.

\vspace{0.3 cm}
\textbf{ARM}

Nel caso ARM avviene lo stesso meccanismo. Tra le righe otto e dodici avviene il caricamento dei primi due operandi la somma parziale e infine la somma totale.

\vspace{0.3 cm}
\textbf{x86}

Infine per x86 il calcolo avviene tra le righe sette e undici nello stesso modo con cui viene eseguito in ARM.

\begin{figure}[ht]
 
 \begin{subfigure}[b]{0.3\textwidth}
 
 \lstinputlisting[language = Risc-v, caption = RISC-V] {PorzioniCodice/ConfrontoCompilatori/Assembler/RISC-V/sumGen.txt}
	\label{Code:Add2RISC}
\caption{RISC-V}
 \end{subfigure}
 \hfill
 \begin{subfigure}[b]{0.3\textwidth}
 
 \lstinputlisting[language = Risc-v, caption = ARM]{PorzioniCodice/ConfrontoCompilatori/Assembler/ARM/sumGen.txt}
 \label{Code:Add2ARM}

 \end{subfigure}
 \hfill
 \begin{subfigure}[b]{0.3\textwidth}
 
 \lstinputlisting[language = Risc-v, caption = x86]{PorzioniCodice/ConfrontoCompilatori/Assembler/x86/sumGen.txt}
	 
	\label{Code:Add2X86}
 \end{subfigure}
 
 \caption{Funzione di somma}
 \label{Fig:code2}
\end{figure}



\subsection{Moltiplicazione}

\vspace{0.3 cm}
\textbf{Moltiplicazioni per potenze di 2}

\lstinputlisting[language=C, style = Cstyle, caption = {Moltiplicazione per potenza di 2}, label = {Code:Mul2Comp}]{PorzioniCodice/ConfrontoCompilatori/C/mult2.c}

La funzione dato un numero di tipo intero restituisce il numero moltiplicato per due. Per i sorgenti le parti di preparazione sono simili per le rispettive preparazioni precedenti.


\vspace{0.3 cm}
Nei sorgenti in figura \ref{Fig:code2} viene mostrata l'operazione di moltiplicazione per due. Questa avviene per RISC-V e per ARM tramite uno shift logical left di un bit (SLLIW) mentre per x86 avviene tramite una somma. Questa somma è un caso particolare, infatti se volessimo moltiplicare per una qualsiasi potenza di due le operazioni avvengono tutte tramite shift left di un opportuno valore. Con la figura \ref{Fig:mult8} viene mostrato il calcolo di una moltiplicazione per otto. In tutti i casi il calcolo avviene attraverso Shift.


\vspace{0.3 cm}

\begin{figure}
 
 \begin{subfigure}[b]{0.3\textwidth}
 
 \lstinputlisting[language = risc-v, caption = RISC-V]{PorzioniCodice/ConfrontoCompilatori/Assembler/RISC-V/mult2.txt}
 

	\label{Code:Mul2RISC}
 \end{subfigure}
 \hfill
 \begin{subfigure}[b]{0.3\textwidth}
 
 \lstinputlisting[language = risc-v, caption = ARM]{PorzioniCodice/ConfrontoCompilatori/Assembler/ARM/mult2.txt}	
	
		\label{Code:Mul2ARM}
 \end{subfigure}
 \hfill
 \begin{subfigure}[b]{0.3\textwidth}
 
 \lstinputlisting[language = risc-v, caption = x86]{PorzioniCodice/ConfrontoCompilatori/Assembler/x86/mult2.txt}

	\label{Code:Mul2X86}
 \end{subfigure}
 \caption{Moltiplicazione per 2}
 \end{figure}
 	
 \begin{figure}
 \begin{subfigure}[b]{0.3\textwidth}
 
 \lstinputlisting[language = risc-v, caption = RISC-V]{PorzioniCodice/ConfrontoCompilatori/Assembler/RISC-V/mult8.txt}	
		
		\label{Code:Mul8RISC}
 \end{subfigure}
 \hfill
 \begin{subfigure}[b]{0.3\textwidth}
 
 \lstinputlisting[language = risc-v, caption = ARM]{PorzioniCodice/ConfrontoCompilatori/Assembler/ARM/mult8.txt}	

		\label{Code:Mul8ARM}
 \end{subfigure}
 \hfill
 \begin{subfigure}[b]{0.3\textwidth}
 
 \lstinputlisting[language = risc-v, caption = x86]{PorzioniCodice/ConfrontoCompilatori/Assembler/x86/mult8.txt}	

		\label{Code:Mul8X86}
 \end{subfigure}
 
 \caption{Moltiplicazione per 8}
 \label{Fig:mult8}
\end{figure}

\vspace{0.3 cm}

\textbf{Moltiplicazione per una costante}

Vengono presentati due codici molto simili, il primo moltiplica il numero per trentuno che rappresenta più in generale un numero che dista da una potenza di due di uno. Il secondo è un caso più generale dove avviene la moltiplicazione di un numero non potenza di due e che dista da una potenza almeno di due, nel nostro caso il numero è trenta.

\vspace{0.2 cm }

\begin{figure}[ht]
	\begin{subfigure}[b]{0.4\textwidth}
 
 \lstinputlisting[language=C, style = Cstyle, label = {Code:Mul31Comp}, caption = {moltiplicazione per 31}]{PorzioniCodice/ConfrontoCompilatori/C/mult31.c}	
		
 \end{subfigure}
 \hfill
 \begin{subfigure}[b]{0.4\textwidth}
 
 \lstinputlisting[language=C, style = Cstyle, label = {Code:Mul30Comp}, caption = {moltiplicazione per 30}]{PorzioniCodice/ConfrontoCompilatori/C/mult30.c}	
		
 \end{subfigure}
 
\end{figure}

\vspace{0.3 cm}

Nel caso della moltiplicazione per trentuno l'approccio dei tre sorgenti è identico. Viene calcolata la moltiplicazione per trentadue attraverso shift logici e poi viene sottratto una volta il valore per ottenere la moltiplicazione per trentuno. Se il valore costante fosse trentatré, il numero successivo alla potenza di due, l'operazione di sottrazione viene sostituita con una di addizione. Nel caso più generale invece abbiamo un approccio differente.

Partendo dal x86 la moltiplicazione avviene semplicemente con l'istruzione imul a riga sei. Nel caso ARM l'operazione di moltiplicazione viene comunque eseguita da una singola istruzione(riga otto) ma vengono utilizzati i registri r2 e r3 che precedentemente (riga sei e sette) vengono riempiti con gli operandi. Infine l'implementazione di RISC-V utilizza ancora shift. Nel caso della moltiplicazione per trenta avviene prima uno shift di quattro ( moltiplicazione per sedici) successivamente sottratto una volta il numero e infine al risultato avviene applicato uno shift di uno (moltiplicazione per due). Quindi: 
\begin{center}
	\vspace{0.2cm}
$((num * 2^4) - num ) * 2^1 = $ 

$ =((num * 16 ) - num ) * 2 =$ 

$ = 15 * num * 2 = num *30 $ 
\end{center}


\vspace{0.2 cm}
In generale RISC-V utilizza opportuni shift combinate con addizioni e sottrazioni per ottenere il valore della costante.

\begin{figure}[h]

 \begin{subfigure}[b]{0.3\textwidth}
 
 \lstinputlisting[language = risc-v, caption = {RISC-V}]{PorzioniCodice/ConfrontoCompilatori/Assembler/RISC-V/mult31.txt}
 \label{Code:Mul31RISC}


 \end{subfigure}
 \hfill
 \begin{subfigure}[b]{0.3\textwidth}
 
 \lstinputlisting[language = risc-v, caption = ARM]{PorzioniCodice/ConfrontoCompilatori/Assembler/ARM/mult31.txt}	
		
		 \label{Code:Mul31ARM}
 \end{subfigure}
 \hfill
 \begin{subfigure}[b]{0.3\textwidth}
 
 \lstinputlisting[language = risc-v, caption = x86]{PorzioniCodice/ConfrontoCompilatori/Assembler/x86/mult31.txt}
	
	 \label{Code:Mul31X86}
 \end{subfigure}
 \caption{Moltiplicazione per 31}
 \end{figure}

\begin{figure}

 \begin{subfigure}[b]{0.3\textwidth}
 
 \lstinputlisting[language = risc-v, caption = RISC-V]{PorzioniCodice/ConfrontoCompilatori/Assembler/RISC-V/mult30.txt}
 \label{Code:Mul30RISC}
	

 \end{subfigure}
 \hfill
 \begin{subfigure}[b]{0.3\textwidth}
 
 \lstinputlisting[language = risc-v, caption = ARM]{PorzioniCodice/ConfrontoCompilatori/Assembler/ARM/mult30.txt}	
		
		 \label{Code:Mul30ARM}
 \end{subfigure}
 \hfill
 \begin{subfigure}[b]{0.3\textwidth}
 
 \lstinputlisting[language = risc-v, caption = x86]{PorzioniCodice/ConfrontoCompilatori/Assembler/x86/mult30.txt}
	
	 \label{Code:Mul30X86}
 \end{subfigure}
 \caption{Moltiplicazione per 30}
 \end{figure}

\vspace{2cm}

\subsection{Divisione}
Per quanto riguarda la divisione viene utilizzato la stessa metodologia della moltiplicazione.


\todo{manca una analisi, hai solo mostrato come vengono tradotte in assembly, ma non metti commenti}

\newpage
\section{Sorting}
Gli algoritmi di ordinamento sono una parte importante dell'elaborazione dei dati e sono ampiamente utilizzati in molti aspetti, ad esempio in crittografia e nella ricerca di informazioni. Esistono molti tipi di algoritmi di ordinamento e ognuno ha i suoi vantaggi e limiti. In informatica, l'algoritmo di ordinamento è solitamente classificato come segue.

\begin{itemize}
	\item La complessità temporale. Si basano su quanti valori si ha da distribuire. Questi vengono indicati con n.Possiamo avere una prestazione buona come $\mathcal{O}(n\log{}n)$ oppure peggiori come $\mathcal{O}(n!)$.
	\item Memoria utilizzata.
	\item Stabilita ovvero se viene preservato l'ordine relativo dei dati con chiavi uguali all'interno dei valori da ordinare.
\end{itemize}

In base alle proprietà dei diversi tipi di dati, l'efficienza può essere migliorata scegliendo algoritmi di ordinamento appropriati. In questo capitolo verranno descritti quattro algoritmi di ordinamento e verranno analizzati comparandoli all esecuzione su raspberry. L'ordinamento a cui si fa riferimento nelle sezioni successive è un ordinamento di array da mettere in ordine non decrescente.

\subsection{Bubble sort}
Bubble sort è un semplice algoritmo di ordinamento. 
L'algoritmo funziona nel modo seguente:
\begin{itemize}
	\item Confronta gli elementi adiacenti, se il primo è maggiore del secondo, scambialo.
	\item Fai lo stesso confronto di prima dalla prima coppia all'ultima coppia. 
	\item Ripeti i 2 passaggi precedenti per tutti gli elementi tranne l'ultimo.
	\item Ripeti tutti i 3 passaggi precedenti finché non sono necessari elementi da scambiare.
\end{itemize}
L'efficienza dell algoritmo è basata sull'ordinamento dell array da ordinare. Nel caso migliore l'array è gia ordinato e, passandolo all algoritmo, esegue solo il punto 1 dall inizio alla fine. In contrario il caso peggiore è quando l'array si trova nell ordine non crescente.
\begin{table}[ht]
	\centering
	\begin{tabular}{lc}
 & Complessità \\
Caso peggiore & $ \mathcal{O}(n^2)$ \\
Caso migliore & $ \mathcal{O}(n)$ \\
\end{tabular}
	\caption{complessita bubble sort}
	\label{Tab:CompBubbleSort}
\end{table}

Di seguito viene riportato il codice (Code \ref{Code:BubbleSort}) dell'algoritmo e i tempi di esecuzione(Tab \ref{Tab:Tempi esecuzione Bubblesort}) secondo la dimensione dell array e la situazione iniziale dell array:
\lstinputlisting[language=C, style = Cstyle, caption = {Algoritmo bubble sort scritto in c}, label = {Code:BubbleSort}]{PorzioniCodice/Sorting/Bubble.c}	

\begin{table}[ht]
\centering
\begin{tabular}{| l | l | l | l |}
\hline
 & Caso peggiore & Caso migliore & Caso Generale \\ \hline
500 & 0.009426 & 0.004667 & 0.007156 \\ \hline
1000 & 0.037558 & 0.018877 & 0.028745 \\ \hline
5000 & 0.941429 & 0.470478 & 0.718178 \\ \hline
10000 & 3.784664 & 1.893387 & 2.889989 \\ \hline
20000 & 15.249109 & 7.639312 & 11.617705 \\ \hline
35000 & 46.744558 & 23.460390 & 35.640101 \\ \hline
50000 & 95.389578 & 47.888541 & 72.735791 \\ \hline
\end{tabular}
\caption{Tempi di esecuzione bubble sort in ms}
\label{Tab:Tempi esecuzione Bubblesort}
\end{table}

\newpage
\subsection{Insertion sort}
L'arlogitmo consiste nel considerare un elemento alla volta, inserendo ciascuno nella posizione corretta tra gli elementi che sono stati ordinati. 
\begin{table}[ht]
	\centering
	\begin{tabular}{lc}
 & Complessità \\
Caso peggiore & $ \mathcal{O}(n!)$ \\
Caso migliore & $ \mathcal{O}(n)$ \\
Caso medio & $ \mathcal{O}(n!)$\\
\end{tabular}
	\caption{complessita insertion sort}
	\label{Tab:CompInsertionSort}
\end{table}


\lstinputlisting[language=C, style = Cstyle, caption = {Algoritmo bubble sort scritto in c}, label = {Code:InsertionSort}]{PorzioniCodice/Sorting/Insertion.c}	

Come nel caso del bubble sort è riportato anche il tempo di esecuzione nel caso peggiore e migliore.

\begin{table}[ht]
\centering
\begin{tabular}{| l | l | l | l |}
\hline
 & Caso peggiore & Caso migliore & Caso Generale \\ \hline
500 & 0.005423 & 0.000028 & 0.002634 \\ \hline
1000 & 0.020836	 & 0.000055 & 0.010575 \\ \hline
5000 & 0.521686 & 0.000287 & 0.260862 \\ \hline
10000 & 2.103697 & 0.000645 & 1.048553 \\ \hline
20000 & 8.497346 & 0.001114 & 4.220421 \\ \hline
35000 & 26.066370 & 0.001928 & 12.969309 \\ \hline
50000 & 53.187672 & 0.002720 & 26.499820 \\ \hline

\end{tabular}
\caption{Tempi di esecuzione insertion sort in ms}
\label{Tab:Tempi esecuzione InsertionSort}
\end{table}


\subsection{QuickSort}
L'algoritmo quicksort è un algoritmo ricorsivo del tipo divide et impera.L'algoritmo si basa:

\begin{itemize}
\item Scegli un pivot dagli elementi dell'array.
\item Ordina l'array.Se l'elemento è più grande del pivot, allora mettilo dopo il pivot, altrimenti prima.
\item Ripetere questi due passaggi per i sottoarray finché ogni elemento non è nell'ordine corretto.
\end{itemize}

Il tempo di esecuzione nel caso peggiore di $\mathcal{O}(n!) $, il tempo di esecuzione medio di quicksort è $\mathcal{O}(n * \log{}n) $. In seguito viene mostrato l'implementazione 

\lstinputlisting[language=C, style = Cstyle, caption = {Algoritmo quick sort scritto in c}, label = {Code:QuickSort}]{PorzioniCodice/Sorting/Quick.c}	

\begin{table}[ht]
\centering
\begin{tabular}{| l | l |}
\hline
 & Tempo \\ \hline
500 & 0.000273 \\ \hline
1000 & 0.000610 \\ \hline
5000 & 0.003813 \\ \hline
10000 & 0.008423 \\ \hline
20000 & 0.017266 \\ \hline
35000 & 0.032285 \\ \hline
50000 & 0.048096 \\ \hline

\end{tabular}
\caption{Tempi di esecuzione quick sort in ms}
\label{Tab:Tempi esecuzione QuickSort}
\end{table}

\subsection{Heap sort}
L'heapsort è un algoritmo di ordinamento iterativo l'implementazione utilizzata è in-place.

\lstinputlisting[language=C, style = Cstyle, caption = {Algoritmo heap sort scritto in c}, label = {Code:HeapSort}]{PorzioniCodice/Sorting/Heap.c}	

\begin{table}[ht]
\centering
\begin{tabular}{| l | l |}
\hline
 & Tempo \\ \hline
500 & 0.000569 \\ \hline
1000 & 0.001272 \\ \hline
5000 & 0.008016 \\ \hline
10000 & 0.017815 \\ \hline
20000 & 0.041886 \\ \hline
35000 & 0.083366 \\ \hline
50000 & 0.128863 \\ \hline

\end{tabular}
\caption{Tempi di esecuzione heap sort in ms}
\label{Tab:Tempi esecuzione HeapSort}
\end{table}


\begin{figure}[ht]
 \centering
 \begin{subfigure}[t]{0.45\textwidth}
 \centering
 \includegraphics[width=\textwidth]{Img/GraficiSorting/Sorting1.png}
 \caption{Bubblesort insertionsort, heapsort e quicksort}
 \label{Fig:AllSortingAlg}
 \end{subfigure}
 \hfill
 \begin{subfigure}[t]{0.45\textwidth}
 \centering
 \includegraphics[width=\textwidth]{Img/GraficiSorting/Sorting2.png}
 \caption{Quicksort e Heapsort}
 \label{Fig:QHSort}
 \end{subfigure}

 \caption{Algoritmi di oridinamento a confronto}
 \label{Fig:AllSort}
\end{figure}


\subsection{Confronto Sorting}
In questa sezione vengono visualizzati i risultati a confronto. Per prima cosa iniziamo con confrontare i risultati con l'esecuzione su MacBook.


\begin{figure}[ht]
\centering
 \includegraphics[scale=0.8]{Img/GraficiSorting/BubbleSort_Pc_Riscv.PNG}
 \caption{Tempi di esecuzione Bubblesort PC e RISC-V}
\end{figure}

\begin{figure}[ht]
\centering
 \includegraphics[scale=0.8]{Img/GraficiSorting/InsertionsortPcRisc.PNG}
 \caption{Tempi di esecuzione Insertionsort PC e RISC-V}
\end{figure}
	
\begin{figure}[ht]
\centering
 \includegraphics[scale=0.8]{Img/GraficiSorting/QuicksortPCRisc.PNG}
 \caption{Tempi di esecuzione Quicksort PC e RISC-V}
\end{figure}

\begin{figure}[ht]
\centering
 \includegraphics[scale=0.8]{Img/GraficiSorting/Heapsort_PC_RISC}
 \caption{Tempi di esecuzione Heapsort PC e RISC-V}
\end{figure}


	\begin{table}[ht]
		\centering
		\begin{tabular}		{| l | c | c | c | c |}
		\hline
		 & Bubblesort & Insertionsort & Heapsort & Quicksort \\ \hline
500 & 0.000491 & 0.000196 & 0.000057 & 0.000052 \\ \hline
1000 & 0.001871	 & 0.000723 & 0.000145 & 0.000080 \\ \hline
5000 & 0.055505 & 0.016859 & 0.000975 & 0.000544 \\ \hline
10000 & 0.247916 & 0.066411 & 0.002083 & 0.001164 \\ \hline
20000 & 1.056383 & 0.261627 & 0.004485 & 0.002441 \\ \hline
35000 & 3.359662 & 0.800075 & 0.008340 & ;0.004557 \\ \hline
50000 & 7.019640 & 1.633171 & 0.012359 & 0.006857 \\ \hline

		\end{tabular}
		\caption{Tempi di esecuzione degli algoritmi di sorting su PC in ms}
		\label{Fig:PcSort}
	\end{table}

La tabella \ref{Fig:PcSort} mostra i tempi di esecuzione degli algoritmi di ordinamento eseguiti sul PC. 
Un altro confronto lo possiamo fare con Raspberry pi \footnote{Il modello utilizzato è il modello Raspberry model B mostrato in figura \ref{fig:RaspberryB} }.



\begin{table}[ht]
		\centering
		\begin{tabular}		{| l | c | c | c | c |}
		\hline
		 & Bubblesort & Insertionsort & Heapsort & Quicksort \\ \hline
500 & 0.020337 & 0.004877 & 0.000825 & 0.000511 \\ \hline
1000 & 0.078527	 & 0.020353 & 0.001894 & 0.001141 \\ \hline
5000 & 2.030446 & 0.045018 & 0.013863 & 0.009072 \\ \hline
10000 & 8.535436 & 1.874295 & 0.027671 & 0.018542 \\ \hline
20000 & 34.733894 & 7.842624 & 0.058596 & 0.038194 \\ \hline
35000 & 117.622606 & 24.076289 & 0.114716 & 0.082891 \\ \hline
50000 & 250.008917 & 51.757841 & 0.210807 & 0.157344 \\ \hline

		\end{tabular}
		\caption{Tempi di esecuzione Raspberry Pi B in ms}
		\label{Tab:RaspSorting}
			\end{table}

\begin{figure}[ht]
\centering
	\includegraphics[scale=0.8]{Bubblesort_RB_RISC.PNG}
	\caption{Tempi di esecuzione Bubblesort Raspberry e RISC-V}
	\label{GrafBubble}
\end{figure}

\begin{figure}[ht]
\centering
	\includegraphics[scale=0.8]{Insertionsort_RB_RISC.PNG}
	\caption{Tempi di esecuzione Insertionsort Raspberry e RISC-V}
	\label{GrafInsertion}
\end{figure}
\begin{figure}[ht]
\centering
	\includegraphics[scale=0.8]{Quicksort_RB_RISC.PNG}
	\caption{Tempi di esecuzione Quicksort Raspberry e RISC-V}
	\label{GrafQuick}
\end{figure}
\begin{figure}[ht]
\centering
	\includegraphics[scale=0.8]{Heapsort_RB_RISC.PNG}
	\caption{Tempi di esecuzione Heapsort Raspberry e RISC-V}
	\label{GrafHeap}
\end{figure}

I grafici \ref{GrafBubble} \ref{GrafInsertion} \ref{GrafQuick} \ref{GrafHeap} mostrano i tempi di esecuzione degli algoritmi di sorting comparati tra Rasberry e RISC-V. In ogni grafico si vede che il tempo di esecuzione è migliore su RISC-V. Prendendo in considerazione il Bubblesort nel caso con 50000 elementi la board con processore RISC-V è 4 volte piu veloce del raspberry in altri casi, come ad esempio per heap sort, il miglioramente di RISC-V è 1.6 rispetto a Raspberry. 


\begin{figure}[ht]
\centering
 \includegraphics[scale=0.8]{Img/GraficiSorting/Bubblesort_All.PNG}
 \caption{Tempi di esecuzione Bubblesort}
\end{figure}

\begin{figure}[ht]
\centering
 \includegraphics[scale=0.8]{Img/GraficiSorting/Insertionsort_All.PNG}
 \caption{Tempi di esecuzione Insertionsort}
\end{figure}
	
\begin{figure}[ht]
\centering
 \includegraphics[scale=0.8]{Img/GraficiSorting/Quicksort_All.PNG}
 \caption{Tempi di esecuzione Quicksort}
\end{figure}

\begin{figure}[ht]
\centering
 \includegraphics[scale=0.8]{Img/GraficiSorting/Heapsort_All}
 \caption{Tempi di esecuzione Heapsort}
\end{figure}


%--------

\chapter{Conclusione}
%PUNTI conclusivi(cosa posso dire)
% ISA -> due parole per sottolineare open
% Risultati CoreMark
% Risultati linpack
% Codice comparato: RISC-V piu linee di codice che ARM
% commentare

%ISA
Nonostante RISC-V non sia la prima ISA open source\todo{mi è sfuggito dove citavi altre...}, sta guadagnando sempre più popolarità grazie alla sua semplicità, alla sua caratteristica di modularità. In questa tesi si sono fatti alcuni test su RISC-V. 


%CoreMark, Linpack


%Multshift
Per quanto riguarda il codice assembly generato il compilatore RISC-V genera codice di dimensioni maggiore rispetto ad ARM. RISC-V rischiede pi\'u spazio quindi è pi\'u costoso in termini di memoria di programma richiesta. 
\todo{mmmm, quanto? hai fatto conti? poi con la disponibilità di memoria di oggi quanto incide?}

%Sorting
Per quanto riguarda il sorting il confronto con gli algoritmi tra RISC-V, il Raspberry e il pc mostra che l board dotata di RISC-V è sempre più veloce del Raspberry in ogni algoritmo ma è sempre più lento del pc.
\todo{riassumi qualche numero, di quanto?}

Possiamo concludere osservando che la board RISC-V è una valida sostituta del Raspberry in termini di velocit\'a di calcolo.% ma il codice che genera il compilatore RISC-V è di dimensione maggiore rispetto a quello di ARM.

Questa tesi analizza solo alcuni aspetti di RISC-V, terminato questo lavoro di tesi vorrei sottolineare che non si tratta di un lavoro concluso, ma un punto di partenza per possibili approfondimenti futuri. 

\todo{conclusione minimale, riesci a dire se ci sono aspetti in cui uno è meglio dell'altro e viceversa? comparazioni di costo? corrente consumata? ecc.}

%\todo{atrent: nelle conclusioni dovresti a questo punto (a valle del tuo lavoro di analisi) poter dire non solo come si confronta risc-v con gli altri, ma anche quali sono le aree di debolezza e forza, tanto da ipotizzare quale potrebbero essere i contesti d'uso favorevoli}



%\addcontentsline{toc}{chapter}{Bibliografia}

\printbibliography 

\end{document}
